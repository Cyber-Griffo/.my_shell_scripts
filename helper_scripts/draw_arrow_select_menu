#!/bin/bash

# little helpers for terminal print control and key input
ESC=$(printf "\033")
cursor_blink_on() { printf "$ESC[?25h"; }
cursor_blink_off() { printf "$ESC[?25l"; }
cursor_to() { printf "$ESC[$1;${2:-1}H"; }
print_option() { printf "$(tput setaf $1)   $2 $(tput sgr0)"; }
print_selected() { printf "$(tput setaf $1)  $ESC[7m $2 $ESC[27m$(tput sgr0)"; }
get_cursor_row() {
  IFS=';' read -sdR -p $'\E[6n' ROW COL
  echo ${ROW#*[}
}
key_input() {
  read -s -n3 key 2>/dev/null >&2
  if [[ $key = $ESC[A ]]; then echo up; fi
  if [[ $key = $ESC[B ]]; then echo down; fi
  if [[ $key = "" ]]; then echo enter; fi
}

# initially print empty new lines (scroll down if at bottom of screen)
for opt; do printf "\n"; done

# determine current screen position for overwriting the options
lastrow=$(get_cursor_row)
startrow=$(($lastrow - $#))

# ensure cursor and input echoing back on upon a ctrl+c during read -s
trap "cursor_blink_on; stty echo; printf '\n'; exit" 1
cursor_blink_off

selected=0
colors=($(seq 1 $(($# * 2))))
while true; do
  # print options by overwriting the last lines
  idx=0
  for opt; do
    cursor_to $(($startrow + $idx))
    if [ $idx -eq $selected ]; then
      print_selected $((${colors[$idx]} % 8 + 1)) "$opt"
    else
      print_option $((${colors[$idx]} % 8 + 1)) "$opt"
    fi
    ((idx++))
  done

  # user key control
  case $(key_input) in
  enter) break ;;
  up)
    ((selected--))
    if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi
    ;;
  down)
    ((selected++))
    if [ $selected -ge $# ]; then selected=0; fi
    ;;
  esac
done

# cursor position back to normal
cursor_to $lastrow
printf "\n"
cursor_blink_on

export SELECTED=$selected
